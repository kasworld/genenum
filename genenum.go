// Copyright 2015,2016,2017,2018,2019 SeukWon Kang (kasworld@gmail.com)
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//    http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"
)

func makeGenComment() string {
	return fmt.Sprintf("// Code generated by \"%s %s\"\n",
		filepath.Base(os.Args[0]), strings.Join(os.Args[1:], " "))
}

// loadEnumWithComment load list of enum + comment
func loadEnumWithComment(filename string) ([][]string, error) {
	fd, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer fd.Close()
	rtn := make([][]string, 0)
	rd := bufio.NewReader(fd)
	for {
		line, err := rd.ReadString('\n')
		line = strings.TrimSpace(line)
		if len(line) != 0 && line[0] != '#' {
			s2 := strings.SplitN(line, " ", 2)
			if len(s2) == 1 {
				s2 = append(s2, "")
			}
			s2[1] = strings.TrimSpace(s2[1])
			rtn = append(rtn, s2)
		}
		if err != nil { // eof
			break
		}
	}
	return rtn, nil
}

// saveTo save go source with format, saved file may need goimport
func saveTo(outdata *bytes.Buffer, buferr error, outfilename string, verbose bool) error {
	if buferr != nil {
		fmt.Printf("fail %v %v\n", outfilename, buferr)
		return buferr
	}
	src, err := format.Source(outdata.Bytes())
	if err != nil {
		fmt.Println(outdata)
		fmt.Printf("fail %v %v\n", outfilename, err)
		return err
	}
	if werr := ioutil.WriteFile(outfilename, src, 0644); werr != nil {
		fmt.Printf("fail %v %v\n", outfilename, werr)
		return werr
	}
	if verbose {
		fmt.Printf("goimports -w %v\n", outfilename)
	}
	return nil
}

var (
	g_typename    = flag.String("typename", "", "enum typename")
	g_basedir     = flag.String("basedir", "", "base directory of enumdata, gen code ")
	g_packagename = flag.String("packagename", "", "load basedir/packagename.enum")
	g_flagtype    = flag.String("flagtype", "", "make flag code, empty not generate")
	g_vectortype  = flag.String("vectortype", "", "vector element type, empty not generate")
	g_verbose     = flag.Bool("verbose", false, "show goimports file")
)

func main() {
	flag.Parse()

	if *g_typename == "" {
		fmt.Println("typename not set")
	}
	if *g_packagename == "" {
		fmt.Println("packagename not set")
	}
	if *g_basedir == "" {
		fmt.Println("base dir not set")
	}

	os.MkdirAll(path.Join(*g_basedir, *g_packagename), os.ModePerm)

	enumdatafile := path.Join(*g_basedir, *g_packagename+".enum")
	enumdata, err := loadEnumWithComment(enumdatafile)
	if err != nil {
		fmt.Printf("fail to load %v %v\n", enumdatafile, err)
		return
	}

	buf, err := buildEnumCode(*g_packagename, *g_typename, enumdata)
	saveTo(buf, err,
		path.Join(*g_basedir, *g_packagename, *g_packagename+"_gen.go"),
		*g_verbose,
	)

	if *g_flagtype != "" {
		os.MkdirAll(path.Join(*g_basedir, *g_packagename+"_flag"), os.ModePerm)
		buf, err = buildFlagCode(*g_packagename, *g_typename, enumdata, *g_flagtype)
		saveTo(buf, err,
			path.Join(*g_basedir, *g_packagename+"_flag", *g_packagename+"_flag_gen.go"),
			*g_verbose,
		)
	}

	if *g_vectortype != "" {
		os.MkdirAll(path.Join(*g_basedir, *g_packagename+"_vector"), os.ModePerm)
		buf, err = buildVectorCode(*g_packagename, *g_typename, *g_vectortype)
		saveTo(buf, err,
			path.Join(*g_basedir, *g_packagename+"_vector", *g_packagename+"_vector_gen.go"),
			*g_verbose,
		)
	}
}

func buildEnumCode(
	pkgname string, typename string, enumdata [][]string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
		package %[1]s
		import "fmt"
		type %v uint8
	`, pkgname, typename)

	fmt.Fprintf(&buf, "const (\n")
	for i, v := range enumdata {
		if i == 0 {
			fmt.Fprintf(&buf, "%v %v = iota // %v \n", v[0], typename, v[1])
		} else {
			fmt.Fprintf(&buf, "%v // %v\n", v[0], v[1])
		}
	}
	fmt.Fprintf(&buf, `
	%[1]s_Count int = iota 
	)`, typename)

	fmt.Fprintf(&buf, `
	var _%[1]s2string = [%[1]s_Count][2]string{
	`, typename)

	for _, v := range enumdata {
		fmt.Fprintf(&buf, "%v : {\"%v\",\"%v\" },\n", v[0], v[0], v[1])
	}
	fmt.Fprintf(&buf, "\n}\n")
	fmt.Fprintf(&buf, `
	func (e %[1]s) String() string {
		if e >=0 && e < %[1]s(%[1]s_Count) {
			return _%[1]s2string[e][0]
		}
		return fmt.Sprintf("%[1]s%%d", uint8(e))
	}

	func (e %[1]s) CommentString() string {
		if e >=0 && e < %[1]s(%[1]s_Count) {
			return _%[1]s2string[e][1]
		}
		return ""
	}

	`, typename)

	fmt.Fprintf(&buf, `
	var _string2%[1]s = map[string]%[1]s{
	`, typename)

	for _, v := range enumdata {
		fmt.Fprintf(&buf, "\"%v\" : %v, \n", v[0], v[0])
	}
	fmt.Fprintf(&buf, "\n}\n")
	fmt.Fprintf(&buf, `
	func  String2%[1]s(s string) (%[1]s, bool) {
		v, b :=  _string2%[1]s[s]
		return v,b
	}
	`, typename)

	return &buf, nil
}

func buildFlagCode(
	pkgname string, typename string,
	enumdata [][]string, flagtype string) (*bytes.Buffer, error) {

	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
		package %[1]s_flag
		type %[2]sFlag %[3]s
	`, pkgname, typename, flagtype)

	fmt.Fprintf(&buf, "const (\n")
	for _, v := range enumdata {
		fmt.Fprintf(&buf, "%[3]sFlag = %[2]sFlag(1<<%[1]s.%[3]s)  // %[4]s \n",
			pkgname, typename, v[0], v[1])
	}
	fmt.Fprintf(&buf, ")\n")

	fmt.Fprintf(&buf, `
	func (bt *%[1]sFlag) SetBy%[1]s(n %[2]s.%[1]s) {
		*bt |= %[1]sFlag(1 << n)
	}
	
	func (bt *%[1]sFlag) ClearBy%[1]s(n %[2]s.%[1]s) {
		*bt = *bt &^ %[1]sFlag(1<<n)
	}
	
	func (bt %[1]sFlag) TestBy%[1]s(n %[2]s.%[1]s) bool {
		return bt&%[1]sFlag(1<<n) != 0
	}
	
	func (bt *%[1]sFlag) SetBy%[1]sFlag(v %[1]sFlag) {
		*bt |= v
	}
	
	func (bt *%[1]sFlag) ClearBy%[1]sFlag(v %[1]sFlag) {
		*bt = *bt &^ v
	}
	
	func (bt %[1]sFlag) TestBy%[1]sFlag(v %[1]sFlag) bool {
		return bt&v != 0
	}
	`, typename, pkgname)

	return &buf, nil
}

func buildVectorCode(pkgname string, typename string, vectortype string) (*bytes.Buffer, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, makeGenComment())
	fmt.Fprintf(&buf, `
	package %[1]s_vector
	import (
		"bytes"
		"fmt"
		"html/template"
		"net/http"
	)
	`, pkgname, typename)

	fmt.Fprintf(&buf, `
	type %[2]sStat [%[1]s.%[2]s_Count]%[4]s
	func (es *%[2]sStat) String() string {
		var buf bytes.Buffer
		fmt.Fprintf(&buf, "%[2]sVector[")
		for i, v := range es {
			fmt.Fprintf(&buf,
				"%%v:%%v ",
				%[1]s.%[2]s(i), v)
		}
		buf.WriteString("]")
		return buf.String()
	}
	func (es *%[2]sStat) Dec(e %[1]s.%[2]s) {
		es[e]-=1
	}
	func (es *%[2]sStat) Inc(e %[1]s.%[2]s) {
		es[e]+=1
	}
	func (es *%[2]sStat) Add(e %[1]s.%[2]s, v %[4]s) {
		es[e]+=v
	}
	func (es *%[2]sStat) SetIfGt(e %[1]s.%[2]s, v %[4]s) {
		if es[e] < v {
			es[e]=v
		}
	}
	func (es *%[2]sStat) Get(e %[1]s.%[2]s) %[4]s {
		return es[e]
	}

	// Iter return true if iter stop, return false if iter all
	// fn return true to stop iter
	func (es %[2]sStat) Iter(fn func(i int, v %[4]s) bool) bool {
		for i := 0; i < %[1]s.%[2]s_Count; i++ {
			if fn(i, es[i]) {
				return true
			}
		}
		return false
	}

	// VectorAdd add element to element
	func (es %[2]sStat) VectorAdd(arg %[2]sStat) %[2]sStat {
		var rtn %[2]sStat
		for i := 0; i < %[1]s.%[2]s_Count; i++ {
			rtn[i] = es[i] + arg[i]
		}
		return rtn
	}
	
	// VectorSub sub element to element
	func (es %[2]sStat) VectorSub(arg %[2]sStat) %[2]sStat {
		var rtn %[2]sStat
		for i := 0; i < %[1]s.%[2]s_Count; i++ {
			rtn[i] = es[i] - arg[i]
		}
		return rtn
	}
		
	
	func (es *%[2]sStat) ToWeb(w http.ResponseWriter, r *http.Request) error {
		tplIndex, err := template.New("index").Funcs(IndexFn).Parse(%[3]c
		<html>
		<head>
		<title>%[2]s statistics</title>
		</head>
		<body>
		<table border=1 style="border-collapse:collapse;">%[3]c +
			HTML_tableheader +
			%[3]c{{range $i, $v := .}}%[3]c +
			HTML_row +
			%[3]c{{end}}%[3]c +
			HTML_tableheader +
			%[3]c</table>
	
		<br/>
		</body>
		</html>
		%[3]c)
		if err != nil {
			return err
		}
		if err := tplIndex.Execute(w, es); err != nil {
			return err
		}
		return nil
	}
	
	func Index(i int) string {
		return %[1]s.%[2]s(i).String()
	}
	
	var IndexFn = template.FuncMap{
		"%[2]sIndex": Index,
	}
	
	const (
		HTML_tableheader = %[3]c<tr>
		<th>Name</th>
		<th>Value</th>
		</tr>%[3]c
		HTML_row = %[3]c<tr>
		<td>{{%[2]sIndex $i}}</td>
		<td>{{$v}}</td>
		</tr>
		%[3]c
	)
	`, pkgname, typename, '`', vectortype)

	return &buf, nil
}
